// Package rippling provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package rippling

import (
	"bytes"
	"context"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/nullable"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	TokenScopes = "Token.Scopes"
)

// Defines values for CandidateEmploymentType.
const (
	CandidateEmploymentTypeCONTRACTOR CandidateEmploymentType = "CONTRACTOR"
	CandidateEmploymentTypeHOURLYFT   CandidateEmploymentType = "HOURLY_FT"
	CandidateEmploymentTypeHOURLYPT   CandidateEmploymentType = "HOURLY_PT"
	CandidateEmploymentTypeSALARIEDFT CandidateEmploymentType = "SALARIED_FT"
	CandidateEmploymentTypeSALARIEDPT CandidateEmploymentType = "SALARIED_PT"
	CandidateEmploymentTypeTEMP       CandidateEmploymentType = "TEMP"
)

// Defines values for CandidateSalaryUnit.
const (
	DAY       CandidateSalaryUnit = "DAY"
	HOUR      CandidateSalaryUnit = "HOUR"
	MONTH     CandidateSalaryUnit = "MONTH"
	PAYPERIOD CandidateSalaryUnit = "PAY_PERIOD"
	WEEK      CandidateSalaryUnit = "WEEK"
)

// Defines values for CustomFieldsType.
const (
	CURRENCY   CustomFieldsType = "CURRENCY"
	DATE       CustomFieldsType = "DATE"
	FILE       CustomFieldsType = "FILE"
	ID         CustomFieldsType = "ID"
	NUMBER     CustomFieldsType = "NUMBER"
	PERCENTAGE CustomFieldsType = "PERCENTAGE"
	RADIO      CustomFieldsType = "RADIO"
	SELECT     CustomFieldsType = "SELECT"
	TEXT       CustomFieldsType = "TEXT"
	TEXTAREA   CustomFieldsType = "TEXTAREA"
)

// Defines values for EmployeeEmploymentType.
const (
	EmployeeEmploymentTypeCONTRACTOR EmployeeEmploymentType = "CONTRACTOR"
	EmployeeEmploymentTypeHOURLYFT   EmployeeEmploymentType = "HOURLY_FT"
	EmployeeEmploymentTypeHOURLYPT   EmployeeEmploymentType = "HOURLY_PT"
	EmployeeEmploymentTypeSALARIEDFT EmployeeEmploymentType = "SALARIED_FT"
	EmployeeEmploymentTypeSALARIEDPT EmployeeEmploymentType = "SALARIED_PT"
	EmployeeEmploymentTypeTEMP       EmployeeEmploymentType = "TEMP"
)

// Defines values for EmployeeGender.
const (
	EmployeeGenderFEMALE EmployeeGender = "FEMALE"
	EmployeeGenderMALE   EmployeeGender = "MALE"
	EmployeeGenderNil    EmployeeGender = "<nil>"
)

// Defines values for EmployeeIdentifiedGender.
const (
	EmployeeIdentifiedGenderFEMALE    EmployeeIdentifiedGender = "FEMALE"
	EmployeeIdentifiedGenderMALE      EmployeeIdentifiedGender = "MALE"
	EmployeeIdentifiedGenderNONBINARY EmployeeIdentifiedGender = "NONBINARY"
	EmployeeIdentifiedGenderNil       EmployeeIdentifiedGender = "<nil>"
)

// Defines values for EmployeeRoleState.
const (
	ACCEPTED   EmployeeRoleState = "ACCEPTED"
	ACTIVE     EmployeeRoleState = "ACTIVE"
	HIRED      EmployeeRoleState = "HIRED"
	INIT       EmployeeRoleState = "INIT"
	TERMINATED EmployeeRoleState = "TERMINATED"
)

// Defines values for EventEventType.
const (
	ACCOUNTPASSWORDCHANGED       EventEventType = "ACCOUNT_PASSWORD_CHANGED"
	ACCOUNTPASSWORDRESET         EventEventType = "ACCOUNT_PASSWORD_RESET"
	EXTERNALACCOUNTCREATE        EventEventType = "EXTERNAL_ACCOUNT_CREATE"
	EXTERNALACCOUNTDELETE        EventEventType = "EXTERNAL_ACCOUNT_DELETE"
	EXTERNALACCOUNTINVITE        EventEventType = "EXTERNAL_ACCOUNT_INVITE"
	EXTERNALACCOUNTPASSWORDRESET EventEventType = "EXTERNAL_ACCOUNT_PASSWORD_RESET"
	EXTERNALACCOUNTSUSPEND       EventEventType = "EXTERNAL_ACCOUNT_SUSPEND"
	EXTERNALGROUPADD             EventEventType = "EXTERNAL_GROUP_ADD"
	EXTERNALGROUPMEMBERREMOVE    EventEventType = "EXTERNAL_GROUP_MEMBER_REMOVE"
	EXTERNALGROUPREMOVE          EventEventType = "EXTERNAL_GROUP_REMOVE"
	EXTERNALSSOGRANT             EventEventType = "EXTERNAL_SSO_GRANT"
	EXTERNALSSOREVOKE            EventEventType = "EXTERNAL_SSO_REVOKE"
	EXTERNALSSOSIGNIN            EventEventType = "EXTERNAL_SSO_SIGNIN"
	RPASSITEMSHARED              EventEventType = "RPASS_ITEM_SHARED"
	RPASSITEMUNSHARED            EventEventType = "RPASS_ITEM_UNSHARED"
	RPASSITEMUSED                EventEventType = "RPASS_ITEM_USED"
	TWOFACTORDEVICERESET         EventEventType = "TWO_FACTOR_DEVICE_RESET"
	USERLOGINFAILED              EventEventType = "USER_LOGIN_FAILED"
	USERLOGINSUCCESS             EventEventType = "USER_LOGIN_SUCCESS"
)

// Defines values for EventInitiatorType.
const (
	EventInitiatorTypeEXTERNAL EventInitiatorType = "EXTERNAL"
	EventInitiatorTypeROLE     EventInitiatorType = "ROLE"
	EventInitiatorTypeSYSTEM   EventInitiatorType = "SYSTEM"
)

// Defines values for EventSubjectsType.
const (
	EventSubjectsTypeGROUP     EventSubjectsType = "GROUP"
	EventSubjectsTypeROLE      EventSubjectsType = "ROLE"
	EventSubjectsTypeRPASSITEM EventSubjectsType = "RPASS_ITEM"
	EventSubjectsTypeSPOKE     EventSubjectsType = "SPOKE"
	EventSubjectsTypeSPOKEUSER EventSubjectsType = "SPOKE_USER"
)

// Defines values for LeaveRequestLeaveTypeUniqueID.
const (
	JURYDUTY LeaveRequestLeaveTypeUniqueID = "JURY_DUTY"
	SICK     LeaveRequestLeaveTypeUniqueID = "SICK"
	VACATION LeaveRequestLeaveTypeUniqueID = "VACATION"
)

// Defines values for LeaveRequestManagedBy.
const (
	LEAVES LeaveRequestManagedBy = "LEAVES"
	PTO    LeaveRequestManagedBy = "PTO"
	TILT   LeaveRequestManagedBy = "TILT"
)

// Defines values for LeaveRequestStatus.
const (
	APPROVED LeaveRequestStatus = "APPROVED"
	CANCELED LeaveRequestStatus = "CANCELED"
	PENDING  LeaveRequestStatus = "PENDING"
	REJECTED LeaveRequestStatus = "REJECTED"
)

// Defines values for ProcessLeaveRequestsParamsAction.
const (
	Approve ProcessLeaveRequestsParamsAction = "approve"
	Decline ProcessLeaveRequestsParamsAction = "decline"
)

// Address An address object as stored within Rippling.
type Address struct {
	City            *string `json:"city,omitempty"`
	Country         *string `json:"country,omitempty"`
	IsRemote        *bool   `json:"isRemote,omitempty"`
	Phone           *string `json:"phone,omitempty"`
	State           *string `json:"state,omitempty"`
	SteLocationCode *struct {
		CityCode            *string `json:"cityCode,omitempty"`
		CountyCode          *string `json:"countyCode,omitempty"`
		IsOverridden        *string `json:"isOverridden,omitempty"`
		LocationCode        *string `json:"locationCode,omitempty"`
		MunicipalityCode    *string `json:"municipalityCode,omitempty"`
		PsdCode             *string `json:"psdCode,omitempty"`
		SchoolCode          *string `json:"schoolCode,omitempty"`
		StateCode           *string `json:"stateCode,omitempty"`
		TransitDistrictCode *string `json:"transitDistrictCode,omitempty"`
	} `json:"steLocationCode,omitempty"`
	StreetLine1 *string `json:"streetLine1,omitempty"`
	StreetLine2 *string `json:"streetLine2,omitempty"`
	Zip         *string `json:"zip,omitempty"`
}

// AuthenticatedUserMe Information about the Rippling user whose token is being used to access Rippling's API.
type AuthenticatedUserMe struct {
	// Company Unique identifier of the company.
	Company *string `json:"company,omitempty"`

	// ID Unied identifier of the user (likely an admin).
	ID *string `json:"id,omitempty"`

	// WorkEmail Work email of the user.
	WorkEmail *string `json:"workEmail,omitempty"`
}

// Candidate The Rippling candidate model.
type Candidate struct {
	Attachments *[]struct {
		// FileName The file name.
		FileName *string `json:"file_name,omitempty"`

		// FileURL The public URL and name of a pdf/docx/doc/odt file containing documents pertaining to the candidate.
		FileURL *string `json:"file_url,omitempty"`
	} `json:"attachments,omitempty"`

	// CandidateID The unique identifier of the candidate from the ATS.
	CandidateID *string `json:"candidateId,omitempty"`

	// Currency A string field of the official currency as listed in ISO 4217.
	Currency *string `json:"currency,omitempty"`

	// Department This is the id of the department from GET/departments.
	Department *string `json:"department,omitempty"`

	// Email The candidate's email.
	Email *string `json:"email,omitempty"`

	// EmploymentType The ENUM type of employment the user will have within Rippling.
	EmploymentType *CandidateEmploymentType `json:"employmentType,omitempty"`

	// EquityShares The number of shares that will be given to the candidate.
	EquityShares *int `json:"equityShares,omitempty"`

	// JobTitle The candidate's job title.
	JobTitle *string `json:"jobTitle,omitempty"`

	// Name The candidate's name.
	Name *string `json:"name,omitempty"`

	// PhoneNumber The candidate's phone number.
	PhoneNumber *string `json:"phoneNumber,omitempty"`

	// SalaryPerUnit The decimal value that the candidate gets paid every salaryUnit time period.
	SalaryPerUnit *float32 `json:"salaryPerUnit,omitempty"`

	// SalaryUnit An ENUM string value, denoting the frequency at which the candidate should be paid once the role begins. Note, the PAY_PERIOD ENUM implies the candidate is paid as per a custom pay period.
	SalaryUnit *CandidateSalaryUnit `json:"salaryUnit,omitempty"`

	// SigningBonus The bonus cash given to the candidate as a part of a one time payment, with two decimal digit precision.
	SigningBonus *float64 `json:"signingBonus,omitempty"`

	// StartDate The would-be start date of the candidate.
	StartDate *openapi_types.Date `json:"startDate,omitempty"`

	// WorkLocation This is the id of the worklocation from GET/work_locations.
	WorkLocation *string `json:"workLocation,omitempty"`
}

// CandidateEmploymentType The ENUM type of employment the user will have within Rippling.
type CandidateEmploymentType string

// CandidateSalaryUnit An ENUM string value, denoting the frequency at which the candidate should be paid once the role begins. Note, the PAY_PERIOD ENUM implies the candidate is paid as per a custom pay period.
type CandidateSalaryUnit string

// Company A company object as represented within Rippling.
type Company struct {
	// Address An address object as stored within Rippling.
	Address nullable.Nullable[Address] `json:"address,omitempty"`

	// Entities This model represents the legal entities inside of a given company. Legal entities based in Canada (CA) are currently supported at this time.
	Entities      *Entities       `json:"entities,omitempty"`
	ID            *string         `json:"id,omitempty"`
	Name          *string         `json:"name,omitempty"`
	Phone         *string         `json:"phone,omitempty"`
	PrimaryEmail  *string         `json:"primaryEmail,omitempty"`
	WorkLocations *[]WorkLocation `json:"workLocations,omitempty"`
}

// CompanyLeaveType Company leave request object
type CompanyLeaveType struct {
	Description *string `json:"description,omitempty"`

	// ID Unique identifier of the company leave request
	ID *string `json:"id,omitempty"`

	// IsUnpaid Is leave type unpaid
	IsUnpaid *bool `json:"isUnpaid,omitempty"`

	// LeaveType Company leave type key
	LeaveType *string `json:"leaveType,omitempty"`

	// Name Company leave type name
	Name *string `json:"name,omitempty"`
}

// CustomField defines model for CustomField.
type CustomField struct {
	CustomFieldTitle1 *string `json:"customFieldTitle1,omitempty"`
	CustomFieldTitleN *string `json:"customFieldTitleN,omitempty"`
}

// CustomFields A Custom Fields object within Rippling.
type CustomFields struct {
	// ID The identifier of the specific custom field.
	ID *string `json:"Id,omitempty"`

	// Required Denotes whether the custom field is or is not mandatory
	Required *bool `json:"required,omitempty"`

	// Title The title of the custom field.
	Title *string `json:"title,omitempty"`

	// Type Denotes the type of the custom field.
	Type *CustomFieldsType `json:"type,omitempty"`
}

// CustomFieldsType Denotes the type of the custom field.
type CustomFieldsType string

// Department A company department object.
type Department struct {
	// ID Unique identifier of the department
	ID *string `json:"id,omitempty"`

	// Name Name of the department
	Name *string `json:"name,omitempty"`

	// Parent id of the parent department, if one exists
	Parent nullable.Nullable[string] `json:"parent,omitempty"`
}

// Employee An employee model object.
type Employee struct {
	CustomFields *CustomField `json:"customFields,omitempty"`

	// Department The employee's department name
	Department *string `json:"department,omitempty"`

	// EmployeeNumber This indicates the sequential employee number within their company. This number continues to grow as each employee is onboarded. i.e if you are the 65th employee to join the company with 32 active employees, the employeeNumber would be 65.
	EmployeeNumber *string `json:"employeeNumber,omitempty"`

	// EmploymentType An ENUM of employment type
	EmploymentType *EmployeeEmploymentType `json:"employmentType,omitempty"`

	// EndDate The employee's end date
	EndDate nullable.Nullable[string] `json:"endDate,omitempty"`

	// FirstName First name of the employee
	FirstName *string `json:"firstName,omitempty"`

	// Gender The employee's gender
	Gender *EmployeeGender `json:"gender,omitempty"`

	// ID This is the unique role ID of the employee. A role ID exists per 1 and only 1 company.
	ID *string `json:"id,omitempty"`

	// IdentifiedGender The employee's identified gender
	IdentifiedGender *EmployeeIdentifiedGender `json:"identifiedGender,omitempty"`

	// IsInternational Whether the employee is an international employee or not.
	IsInternational *bool `json:"isInternational,omitempty"`

	// IsManager Whether the employee is a manger
	IsManager *bool `json:"isManager,omitempty"`

	// IsRemote Whether the employee's job is remote
	IsRemote *bool `json:"isRemote,omitempty"`

	// LastName Last name of the employee
	LastName *string `json:"lastName,omitempty"`

	// Level The level of the employee
	Level *string `json:"level,omitempty"`

	// Manager The unique identifier of the employee's manager. This value can be null.
	Manager *string `json:"manager,omitempty"`

	// Name Full name of the employee
	Name *string `json:"name,omitempty"`

	// Photo The photo of the employee stored in Rippling
	Photo              *string `json:"photo,omitempty"`
	PreferredFirstName *string `json:"preferredFirstName,omitempty"`
	PreferredLastName  *string `json:"preferredLastName,omitempty"`

	// RoleState The employee's role status - roleState meanings:
	//
	// INIT: An initial record of an individual. An offer has not been made and they have not started working at the company.
	//
	// HIRED: An offer has been made but they have not accepted or started yet.
	//
	// ACCEPTED: An offer has been made and they have accepted, but they have not started yet.
	//
	// ACTIVE: The employee currently works at the company and their start date is today or in the past.
	//
	// TERMINATED: The employee is no longer active.
	RoleState *EmployeeRoleState `json:"roleState,omitempty"`

	// SmallPhoto The small photo of the employee stored in Rippling
	SmallPhoto *string                   `json:"smallPhoto,omitempty"`
	SpokeID    nullable.Nullable[string] `json:"spokeId,omitempty"`

	// Teams An array of the teams that the employee is on
	Teams *[]interface{} `json:"teams,omitempty"`

	// Title The employee's work title
	Title *string `json:"title,omitempty"`

	// UserID This is the unique user ID of the employee. A userID can span across 1 or many companies.
	UserID *string `json:"userId,omitempty"`

	// WorkEmail The employee's work email
	WorkEmail nullable.Nullable[string] `json:"workEmail,omitempty"`

	// WorkLocation An address object as stored within Rippling.
	WorkLocation nullable.Nullable[Address] `json:"workLocation,omitempty"`

	// WorkSchedule The employee's weekly work schedule
	WorkSchedule *map[string]interface{} `json:"workSchedule,omitempty"`

	// WorklocationNickname The work location nickname
	WorklocationNickname *string `json:"worklocationNickname,omitempty"`
}

// EmployeeEmploymentType An ENUM of employment type
type EmployeeEmploymentType string

// EmployeeGender The employee's gender
type EmployeeGender string

// EmployeeIdentifiedGender The employee's identified gender
type EmployeeIdentifiedGender string

// EmployeeRoleState The employee's role status - roleState meanings:
//
// INIT: An initial record of an individual. An offer has not been made and they have not started working at the company.
//
// HIRED: An offer has been made but they have not accepted or started yet.
//
// ACCEPTED: An offer has been made and they have accepted, but they have not started yet.
//
// ACTIVE: The employee currently works at the company and their start date is today or in the past.
//
// TERMINATED: The employee is no longer active.
type EmployeeRoleState string

// Entities This model represents the legal entities inside of a given company. Legal entities based in Canada (CA) are currently supported at this time.
type Entities struct {
	// CA CA represents Canada.
	CA *[]struct {
		EntityInfo *struct {
			// BusinessNumber The Canada Business Number
			BusinessNumber *string `json:"businessNumber,omitempty"`

			// LegalName The legal name of the entity
			LegalName *string `json:"legalName,omitempty"`
		} `json:"entityInfo,omitempty"`

		// ID The unique Rippling ID of the legal entity
		ID *string `json:"id,omitempty"`

		// IsEor If set to true, the legal entity is Rippling's EOR. If set to false, the legal entity is not on Rippling's EOR.
		IsEor *bool `json:"isEor,omitempty"`
	} `json:"CA,omitempty"`
}

// Event The event model for company activity.
//
// Please note, the event type can be one of the following:
//
// - EXTERNAL_ACCONT_CREATE
// - EXTERNAL_ACCOUNT_INVITE
// - EXTERNAL_ACCOUNT_DELETE
// - EXTERNAL_ACCOUNT_SUSPEND
// - EXTERNAL_ACCOUNT_PASSWORD_RESET
// - EXTERNAL_GROUP_ADD
// - EXTERNAL_GROUP_REMOVE
// - EXTERNAL_GROUP_MEMBER_REMOVE
// - EXTERNAL_GROUP_MEMBER_ADD
// - EXTERNAL_SSO_GRANT
// - EXTERNAL_SSO_REVOKE
// - EXTERNAL_SSO_SIGNIN
// - RPASS_ITEM_SHARED
// - RPASS_ITEM_UNSHARED
// - RPASS_ITEM_USED
// - USER_LOGIN_SUCCESS
// - USER_LOGIN_FAILED
// - ACCOUNT_PASSWORD_RESET
// - ACCOUNT_PASSWORD_CHANGED
// - TWO_FACTOR_DEVICE_RESET
type Event struct {
	// Company Unique identifier for the company.
	Company *string `json:"company,omitempty"`

	// EventReason Reason for the event, tied to the type of eveent.
	EventReason nullable.Nullable[struct {
		// Message Message of the event.
		Message *string `json:"message,omitempty"`

		// Reason Reason for the event.
		Reason *string `json:"reason,omitempty"`
	}] `json:"event_reason,omitempty"`

	// EventType An ENUM value for the type of the event.
	EventType *EventEventType `json:"event_type,omitempty"`

	// ID Unique identifier of the event.
	ID *string `json:"id,omitempty"`

	// Initiator The actor of the event.
	Initiator nullable.Nullable[struct {
		// DisplayName The name used within Rippling.
		DisplayName *string `json:"display_name,omitempty"`

		// Icon The icon used within Rippling.
		Icon nullable.Nullable[string] `json:"icon,omitempty"`

		// Role A unique identifier for the employee that initiated the action, if the type is ROLE.
		Role nullable.Nullable[string] `json:"role,omitempty"`

		// Type ENUM value for the type of actor.
		Type *EventInitiatorType `json:"type,omitempty"`
	}] `json:"initiator,omitempty"`

	// LinkedEvents An array of event identifiers that are linked to the event.
	LinkedEvents *[]string `json:"linked_events,omitempty"`

	// Name Display name for the event, tied to the type of event.
	Name *string `json:"name,omitempty"`

	// RequestData Geographic details from where the event was recorded.
	RequestData nullable.Nullable[struct {
		// City City the event was triggered from.
		City *string `json:"city,omitempty"`

		// Country Country the event was triggered from.
		Country *string `json:"country,omitempty"`

		// IP Event IP addresss.
		IP *string `json:"ip,omitempty"`

		// Latitude Latitude the event was triggered from.
		Latitude *string `json:"latitude,omitempty"`

		// Longitude Longitude the event was triggered from.
		Longitude *string `json:"longitude,omitempty"`
	}] `json:"request_data,omitempty"`

	// Spoke Unique identifier for the external application for which the event was recorded. This will be Null for events that don't correspond to an external appliction (e.g. Rippling system and RPass events).
	Spoke nullable.Nullable[string] `json:"spoke,omitempty"`

	// Subjects The list of objects of the event.
	Subjects *[]struct {
		// DisplayName Name used within Rippling.
		DisplayName *string `json:"display_name,omitempty"`

		// Icon Icon used within Rippling.
		Icon nullable.Nullable[string] `json:"icon,omitempty"`

		// Instance Unique key for the event object.
		Instance *string `json:"instance,omitempty"`

		// Type An ENUM value for the type of object.
		Type *EventSubjectsType `json:"type,omitempty"`
	} `json:"subjects,omitempty"`

	// Timestamp Timestamp at which the event was recorded.
	Timestamp *string `json:"timestamp,omitempty"`
}

// EventEventType An ENUM value for the type of the event.
type EventEventType string

// EventInitiatorType ENUM value for the type of actor.
type EventInitiatorType string

// EventSubjectsType An ENUM value for the type of object.
type EventSubjectsType string

// Group defines model for Group.
type Group struct {
	ID *string `json:"id,omitempty"`

	// Name User-readable name of a Rippling group.
	Name *string `json:"name,omitempty"`

	// SpokeID Your id for the group; this should a unique string identifier.
	SpokeID nullable.Nullable[string] `json:"spokeId,omitempty"`

	// Users An array of employee Rippling ids.
	Users *[]string `json:"users,omitempty"`

	// Version The version unique identifier of the group.
	Version *string `json:"version,omitempty"`
}

// GroupUpdatePayload This payload should be used when updating existing groups.
type GroupUpdatePayload struct {
	// Name The name of the Group.
	Name *string `json:"name,omitempty"`

	// SpokeID The external identifier of the Group.
	SpokeID *string `json:"spokeId,omitempty"`

	// Users The array of users within the Group.
	Users *[]interface{} `json:"users,omitempty"`

	// Version The version identifier of the Group.
	Version *string `json:"version,omitempty"`
}

// LeaveBalances Leave balances object
type LeaveBalances struct {
	Empty *string `json:",omitempty"`

	// BalanceWithFutureRequests The remaining balance in minutes for the employee corresponding to the company leave type with future leave requests considered.
	BalanceWithFutureRequests *float32 `json:"balanceWithFutureRequests,omitempty"`

	// BalanceWithoutFutureRequests The remaining balance in minutes for the employee corresponding to the company leave type with future leave requests not considered.
	BalanceWithoutFutureRequests *float32 `json:"balanceWithoutFutureRequests,omitempty"`

	// CompanyLeaveType This is the unique role ID of the company leave types. Corresponds to the ids in response of GET Company Leave Types
	CompanyLeaveType *string `json:"companyLeaveType,omitempty"`

	// IsBalanceUnlimited true if employee's balance corresponding to the company leave type is unlimited, else false
	IsBalanceUnlimited *bool `json:"isBalanceUnlimited,omitempty"`
}

// LeaveRequest Leave request object.
type LeaveRequest struct {
	Comments  nullable.Nullable[string] `json:"comments,omitempty"`
	CreatedAt *string                   `json:"createdAt,omitempty"`
	Dates     *[]struct {
		Date       *openapi_types.Date `json:"date,omitempty"`
		NumMinutes *string             `json:"numMinutes,omitempty"`
	} `json:"dates,omitempty"`
	EndDate            *string                   `json:"endDate,omitempty"`
	EndDateCustomHours nullable.Nullable[string] `json:"endDateCustomHours,omitempty"`
	EndDateEndTime     nullable.Nullable[string] `json:"endDateEndTime,omitempty"`

	// ID Unique identifier of the leave request.
	ID *string `json:"id,omitempty"`

	// IsPaid If the leave request is paid this will be TRUE. Otherwise, this will be FALSE.
	IsPaid            *bool                          `json:"isPaid,omitempty"`
	LeavePolicy       *string                        `json:"leavePolicy,omitempty"`
	LeaveTypeUniqueID *LeaveRequestLeaveTypeUniqueID `json:"leaveTypeUniqueId,omitempty"`

	// ManagedBy This indicates the system that manages the Leave Request. PTO = managed by Rippling's Time Off app. LEAVES = managed by Rippling's Leave Management app. TILT = managed by third-party partner Tilt.
	ManagedBy   *LeaveRequestManagedBy    `json:"managedBy,omitempty"`
	NumHours    nullable.Nullable[string] `json:"numHours,omitempty"`
	NumMinutes  nullable.Nullable[string] `json:"numMinutes,omitempty"`
	PartialDays *[]struct {
		NumMinutes *string             `json:"numMinutes,omitempty"`
		PartialDay *openapi_types.Date `json:"partialDay,omitempty"`
	} `json:"partialDays,omitempty"`
	PolicyDisplayName *string                   `json:"policyDisplayName,omitempty"`
	ProcessedAt       nullable.Nullable[string] `json:"processedAt,omitempty"`

	// ProcessedBy Unique identifier of the employee who approved or rejected the request. This may be null.
	ProcessedBy     nullable.Nullable[string] `json:"processedBy,omitempty"`
	ProcessedByName nullable.Nullable[string] `json:"processedByName,omitempty"`
	ReasonForLeave  nullable.Nullable[string] `json:"reasonForLeave,omitempty"`
	RequestedBy     nullable.Nullable[string] `json:"requestedBy,omitempty"`

	// RequestedByName Unique identifier of the employee who made the request (in most cases this is the same as role).
	RequestedByName nullable.Nullable[string] `json:"requestedByName,omitempty"`

	// Role Unique identifier of the employee who is taking leave.
	Role     *string `json:"role,omitempty"`
	RoleName *string `json:"roleName,omitempty"`

	// RoleTimezone Timezone of the role. This will be work location timezone, or home timezone for employees without a work location.
	RoleTimezone         nullable.Nullable[string] `json:"roleTimezone,omitempty"`
	StartDate            *string                   `json:"startDate,omitempty"`
	StartDateCustomHours nullable.Nullable[string] `json:"startDateCustomHours,omitempty"`
	StartDateStartTime   nullable.Nullable[string] `json:"startDateStartTime,omitempty"`
	Status               *LeaveRequestStatus       `json:"status,omitempty"`
	UpdatedAt            *string                   `json:"updatedAt,omitempty"`
}

// LeaveRequestLeaveTypeUniqueID defines model for LeaveRequest.LeaveTypeUniqueID.
type LeaveRequestLeaveTypeUniqueID string

// LeaveRequestManagedBy This indicates the system that manages the Leave Request. PTO = managed by Rippling's Time Off app. LEAVES = managed by Rippling's Leave Management app. TILT = managed by third-party partner Tilt.
type LeaveRequestManagedBy string

// LeaveRequestStatus defines model for LeaveRequest.Status.
type LeaveRequestStatus string

// Level Levels enable for self-defined,company-wide position levels, such as Manager, Engineering Manager, Executive, etc.
type Level struct {
	// ID Unique identifier of the level.
	ID *string `json:"id,omitempty"`

	// Name Name of the level.
	Name *string `json:"name,omitempty"`

	// Parent The unique identifier of the parent level.
	Parent nullable.Nullable[string] `json:"parent,omitempty"`
}

// Team A team is a self-defined group of employees within Rippling.
type Team struct {
	// ID The identifier of the team.
	ID *string `json:"id,omitempty"`

	// Name The name of the team.
	Name *string `json:"name,omitempty"`

	// Parent The parent team (if this team is a subteam within a larger team).
	Parent nullable.Nullable[string] `json:"parent,omitempty"`
}

// WorkLocation A work location object.
type WorkLocation struct {
	// Address An address object as stored within Rippling.
	Address  nullable.Nullable[Address] `json:"address,omitempty"`
	ID       *string                    `json:"id,omitempty"`
	Nickname *string                    `json:"nickname,omitempty"`
}

// Ein defines model for ein.
type Ein = int

// EmployeeID defines model for employeeId.
type EmployeeID = int

// GroupID defines model for groupId.
type GroupID = int

// Limit defines model for limit.
type Limit = int

// Offset defines model for offset.
type Offset = int

// GetAppAppMatchingUsersParams defines parameters for GetAppAppMatchingUsers.
type GetAppAppMatchingUsersParams struct {
	// AppHandles CSV of app handles. See GET /app_detail/app_handles
	AppHandles *string `form:"app_handles,omitempty" json:"app_handles,omitempty"`
}

// GetCompanyActivityParams defines parameters for GetCompanyActivity.
type GetCompanyActivityParams struct {
	// StartDate Timestamp to list activity after (inclusive). This should be less than 90 days from now. Defaults to 90 days.
	StartDate *openapi_types.Date `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate Timestamp to list activity before (inclusive).
	EndDate *openapi_types.Date `form:"endDate,omitempty" json:"endDate,omitempty"`

	// Next Specifies the pagination cursor to the next page
	Next *string `form:"next,omitempty" json:"next,omitempty"`

	// Limit Specifies the number of results to page (maximum: 1000) (default: 1000)
	Limit *string `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetCompanyLeaveTypesParams defines parameters for GetCompanyLeaveTypes.
type GetCompanyLeaveTypesParams struct {
	ManagedBy *string `form:"managedBy,omitempty" json:"managedBy,omitempty"`
}

// GetCustomFieldsParams defines parameters for GetCustomFields.
type GetCustomFieldsParams struct {
	// Limit Sets a limit on the returned values
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offsets the returned values
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetDepartmentsParams defines parameters for GetDepartments.
type GetDepartmentsParams struct {
	// Limit Sets a limit on the returned values
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offsets the returned values
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetEmployeesParams defines parameters for GetEmployees.
type GetEmployeesParams struct {
	// Limit Sets a limit on the returned values
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offsets the returned values
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetEmployeesIncludeTerminatedParams defines parameters for GetEmployeesIncludeTerminated.
type GetEmployeesIncludeTerminatedParams struct {
	// Limit Sets a limit on the returned values
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offsets the returned values
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// EIN Employer identification number, also known as the Federal Emplower Identification Number or the Federal Tax Identification Number.
	EIN *Ein `form:"EIN,omitempty" json:"EIN,omitempty"`

	// SendAllRoles For integrations that rely on provisioning, this parameter can be used to identify non provisioned roles for compliance purposes. TRUE will return every employee from the company (bypassing any access rules).
	SendAllRoles *bool `form:"send_all_roles,omitempty" json:"send_all_roles,omitempty"`
}

// PostGroupsJSONBody defines parameters for PostGroups.
type PostGroupsJSONBody struct {
	// Name User-readable name of the group.
	Name *string `json:"name,omitempty"`

	// SpokeID The unique ID for the group, this can be the unique identifier for the group entity object within your application.
	SpokeID *string `json:"spokeId,omitempty"`

	// Users An array of Rippling IDs that will be in the group.
	Users *[]string `json:"users,omitempty"`
}

// GetLeaveBalancesParams defines parameters for GetLeaveBalances.
type GetLeaveBalancesParams struct {
	// Limit Sets a limit on the returned values
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offset the returned values
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetLeaveRequestsParams defines parameters for GetLeaveRequests.
type GetLeaveRequestsParams struct {
	ID          *string `form:"id,omitempty" json:"id,omitempty"`
	Role        *string `form:"role,omitempty" json:"role,omitempty"`
	RequestedBy *string `form:"requestedBy,omitempty" json:"requestedBy,omitempty"`
	Status      *string `form:"status,omitempty" json:"status,omitempty"`

	// StartDate Start date of leave.
	StartDate *string `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate End date of leave.
	EndDate     *string `form:"endDate,omitempty" json:"endDate,omitempty"`
	LeavePolicy *string `form:"leavePolicy,omitempty" json:"leavePolicy,omitempty"`
	ProcessedBy *string `form:"processedBy,omitempty" json:"processedBy,omitempty"`

	// From Filter to capture whether the leave request overlaps with a date range.
	From *string `form:"from,omitempty" json:"from,omitempty"`

	// To Filter to capture whether the leave request overlaps with a date range.
	To *string `form:"to,omitempty" json:"to,omitempty"`

	// Limit Sets a limit on the returned values
	Limit *string `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offsets the returned values
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`
}

// PostLeaveRequestsJSONBody defines parameters for PostLeaveRequests.
type PostLeaveRequestsJSONBody struct {
	// CompanyLeaveType Unique identifier of the company leave type
	CompanyLeaveType   string  `json:"companyLeaveType"`
	EndDate            string  `json:"endDate"`
	EndDateCustomHours *string `json:"endDateCustomHours,omitempty"`
	EndDateEndTime     *string `json:"endDateEndTime,omitempty"`

	// ExternalID Object id for corresponding leave obejct in third party system. This may be null.
	ExternalID *string `json:"externalId,omitempty"`

	// LeavePolicy Unique identifier of the leave policy. Required if request is not managed by TILT
	LeavePolicy string `json:"leavePolicy"`

	// ManagedBy String identifier for third party that manages this leave request. This may be null.
	ManagedBy      *string `json:"managedBy,omitempty"`
	ReasonForLeave *string `json:"reasonForLeave,omitempty"`
	RequestedBy    *string `json:"requestedBy,omitempty"`

	// Role Unique identifier of the employee who is taking leave.
	Role                 string  `json:"role"`
	StartDate            string  `json:"startDate"`
	StartDateCustomHours *string `json:"startDateCustomHours,omitempty"`
	StartDateStartTime   *string `json:"startDateStartTime,omitempty"`

	// Status The status to create the leave request in. Only TILT managed requests can take a status other than PENDING.
	Status *string `json:"status,omitempty"`
}

// PatchLeaveRequestsLeaveRequestIDJSONBody defines parameters for PatchLeaveRequestsLeaveRequestID.
type PatchLeaveRequestsLeaveRequestIDJSONBody struct {
	EndDate            *string `json:"endDate,omitempty"`
	EndDateCustomHours *string `json:"endDateCustomHours,omitempty"`
	EndDateEndTime     *string `json:"endDateEndTime,omitempty"`

	// ReasonForLeave Updated reason for leave request. This may be updated even for an APPROVED request.
	ReasonForLeave       *string `json:"reasonForLeave,omitempty"`
	RequestedBy          *string `json:"requestedBy,omitempty"`
	StartDate            *string `json:"startDate,omitempty"`
	StartDateCustomHours *string `json:"startDateCustomHours,omitempty"`
	StartDateStartTime   *string `json:"startDateStartTime,omitempty"`

	// Status Change the status of a request. This is only possible for TILT managed requests.
	Status *string `json:"status,omitempty"`
}

// ProcessLeaveRequestsParams defines parameters for ProcessLeaveRequests.
type ProcessLeaveRequestsParams struct {
	// Action The action to be taken on the leave request. Can be either approved or declined.
	Action ProcessLeaveRequestsParamsAction `form:"action" json:"action"`
}

// ProcessLeaveRequestsParamsAction defines parameters for ProcessLeaveRequests.
type ProcessLeaveRequestsParamsAction string

// GetLevelsParams defines parameters for GetLevels.
type GetLevelsParams struct {
	// Limit Sets a limit on the returned values
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offsets the returned values
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetTeamsParams defines parameters for GetTeams.
type GetTeamsParams struct {
	// Limit Sets a limit on the returned values
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offsets the returned values
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetWorkLocationsParams defines parameters for GetWorkLocations.
type GetWorkLocationsParams struct {
	// Limit Sets a limit on the returned values
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offsets the returned values
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// PostAtsCandidatesPushCandidateJSONRequestBody defines body for PostAtsCandidatesPushCandidate for application/json ContentType.
type PostAtsCandidatesPushCandidateJSONRequestBody = Candidate

// PostGroupsJSONRequestBody defines body for PostGroups for application/json ContentType.
type PostGroupsJSONRequestBody PostGroupsJSONBody

// GetGroupsGroupIDJSONRequestBody defines body for GetGroupsGroupID for application/json ContentType.
type GetGroupsGroupIDJSONRequestBody = GroupUpdatePayload

// PatchGroupsGroupIDJSONRequestBody defines body for PatchGroupsGroupID for application/json ContentType.
type PatchGroupsGroupIDJSONRequestBody = GroupUpdatePayload

// PutGroupsGroupIDJSONRequestBody defines body for PutGroupsGroupID for application/json ContentType.
type PutGroupsGroupIDJSONRequestBody = GroupUpdatePayload

// PostLeaveRequestsJSONRequestBody defines body for PostLeaveRequests for application/json ContentType.
type PostLeaveRequestsJSONRequestBody PostLeaveRequestsJSONBody

// PatchLeaveRequestsLeaveRequestIDJSONRequestBody defines body for PatchLeaveRequestsLeaveRequestID for application/json ContentType.
type PatchLeaveRequestsLeaveRequestIDJSONRequestBody PatchLeaveRequestsLeaveRequestIDJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Rippling which conforms to the OpenAPI3 specification for this service.
type Rippling struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Rippling) error

// Creates a new Rippling, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Rippling, error) {
	// create a client with sane default values
	client := Rippling{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Rippling) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Rippling) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAppAppMatchingUsers request
	GetAppAppMatchingUsers(ctx context.Context, params *GetAppAppMatchingUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAtsCandidatesPushCandidateWithBody request with any body
	PostAtsCandidatesPushCandidateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAtsCandidatesPushCandidate(ctx context.Context, body PostAtsCandidatesPushCandidateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompanies request
	GetCompanies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompanyActivity request
	GetCompanyActivity(ctx context.Context, params *GetCompanyActivityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompanyLeaveTypes request
	GetCompanyLeaveTypes(ctx context.Context, params *GetCompanyLeaveTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomFields request
	GetCustomFields(ctx context.Context, params *GetCustomFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDepartments request
	GetDepartments(ctx context.Context, params *GetDepartmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEmployees request
	GetEmployees(ctx context.Context, params *GetEmployeesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEmployeesIncludeTerminated request
	GetEmployeesIncludeTerminated(ctx context.Context, params *GetEmployeesIncludeTerminatedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEmployeesEmployeeID request
	GetEmployeesEmployeeID(ctx context.Context, employeeID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroups request
	GetGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGroupsWithBody request with any body
	PostGroupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostGroups(ctx context.Context, body PostGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroupsGroupID request
	DeleteGroupsGroupID(ctx context.Context, groupID int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupsGroupIDWithBody request with any body
	GetGroupsGroupIDWithBody(ctx context.Context, groupID int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetGroupsGroupID(ctx context.Context, groupID int, body GetGroupsGroupIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchGroupsGroupIDWithBody request with any body
	PatchGroupsGroupIDWithBody(ctx context.Context, groupID int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchGroupsGroupID(ctx context.Context, groupID int, body PatchGroupsGroupIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutGroupsGroupIDWithBody request with any body
	PutGroupsGroupIDWithBody(ctx context.Context, groupID int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutGroupsGroupID(ctx context.Context, groupID int, body PutGroupsGroupIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLeaveBalances request
	GetLeaveBalances(ctx context.Context, params *GetLeaveBalancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLeaveBalance request
	GetLeaveBalance(ctx context.Context, role string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLeaveRequests request
	GetLeaveRequests(ctx context.Context, params *GetLeaveRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLeaveRequestsWithBody request with any body
	PostLeaveRequestsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostLeaveRequests(ctx context.Context, body PostLeaveRequestsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchLeaveRequestsLeaveRequestIDWithBody request with any body
	PatchLeaveRequestsLeaveRequestIDWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchLeaveRequestsLeaveRequestID(ctx context.Context, id string, body PatchLeaveRequestsLeaveRequestIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelLeaveRequests request
	CancelLeaveRequests(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessLeaveRequests request
	ProcessLeaveRequests(ctx context.Context, id string, params *ProcessLeaveRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLevels request
	GetLevels(ctx context.Context, params *GetLevelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMarkAppInstalled request
	PostMarkAppInstalled(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMe request
	GetMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSamlIdpMetadata request
	GetSamlIdpMetadata(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeams request
	GetTeams(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkLocations request
	GetWorkLocations(ctx context.Context, params *GetWorkLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Rippling) GetAppAppMatchingUsers(ctx context.Context, params *GetAppAppMatchingUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppAppMatchingUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) PostAtsCandidatesPushCandidateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAtsCandidatesPushCandidateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) PostAtsCandidatesPushCandidate(ctx context.Context, body PostAtsCandidatesPushCandidateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAtsCandidatesPushCandidateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) GetCompanies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompaniesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) GetCompanyActivity(ctx context.Context, params *GetCompanyActivityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompanyActivityRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) GetCompanyLeaveTypes(ctx context.Context, params *GetCompanyLeaveTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompanyLeaveTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) GetCustomFields(ctx context.Context, params *GetCustomFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomFieldsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) GetDepartments(ctx context.Context, params *GetDepartmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDepartmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) GetEmployees(ctx context.Context, params *GetEmployeesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmployeesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) GetEmployeesIncludeTerminated(ctx context.Context, params *GetEmployeesIncludeTerminatedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmployeesIncludeTerminatedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) GetEmployeesEmployeeID(ctx context.Context, employeeID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmployeesEmployeeIDRequest(c.Server, employeeID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) GetGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) PostGroupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGroupsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) PostGroups(ctx context.Context, body PostGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGroupsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) DeleteGroupsGroupID(ctx context.Context, groupID int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupsGroupIDRequest(c.Server, groupID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) GetGroupsGroupIDWithBody(ctx context.Context, groupID int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsGroupIDRequestWithBody(c.Server, groupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) GetGroupsGroupID(ctx context.Context, groupID int, body GetGroupsGroupIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsGroupIDRequest(c.Server, groupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) PatchGroupsGroupIDWithBody(ctx context.Context, groupID int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchGroupsGroupIDRequestWithBody(c.Server, groupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) PatchGroupsGroupID(ctx context.Context, groupID int, body PatchGroupsGroupIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchGroupsGroupIDRequest(c.Server, groupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) PutGroupsGroupIDWithBody(ctx context.Context, groupID int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutGroupsGroupIDRequestWithBody(c.Server, groupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) PutGroupsGroupID(ctx context.Context, groupID int, body PutGroupsGroupIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutGroupsGroupIDRequest(c.Server, groupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) GetLeaveBalances(ctx context.Context, params *GetLeaveBalancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLeaveBalancesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) GetLeaveBalance(ctx context.Context, role string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLeaveBalanceRequest(c.Server, role)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) GetLeaveRequests(ctx context.Context, params *GetLeaveRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLeaveRequestsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) PostLeaveRequestsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLeaveRequestsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) PostLeaveRequests(ctx context.Context, body PostLeaveRequestsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLeaveRequestsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) PatchLeaveRequestsLeaveRequestIDWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLeaveRequestsLeaveRequestIDRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) PatchLeaveRequestsLeaveRequestID(ctx context.Context, id string, body PatchLeaveRequestsLeaveRequestIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLeaveRequestsLeaveRequestIDRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) CancelLeaveRequests(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelLeaveRequestsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) ProcessLeaveRequests(ctx context.Context, id string, params *ProcessLeaveRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessLeaveRequestsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) GetLevels(ctx context.Context, params *GetLevelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLevelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) PostMarkAppInstalled(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMarkAppInstalledRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) GetMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) GetSamlIdpMetadata(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSamlIdpMetadataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) GetTeams(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Rippling) GetWorkLocations(ctx context.Context, params *GetWorkLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkLocationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAppAppMatchingUsersRequest generates requests for GetAppAppMatchingUsers
func NewGetAppAppMatchingUsersRequest(server string, params *GetAppAppMatchingUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/app_detail/app_matching_users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppHandles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app_handles", runtime.ParamLocationQuery, *params.AppHandles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAtsCandidatesPushCandidateRequest calls the generic PostAtsCandidatesPushCandidate builder with application/json body
func NewPostAtsCandidatesPushCandidateRequest(server string, body PostAtsCandidatesPushCandidateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAtsCandidatesPushCandidateRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAtsCandidatesPushCandidateRequestWithBody generates requests for PostAtsCandidatesPushCandidate with any type of body
func NewPostAtsCandidatesPushCandidateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/ats_candidates/push_candidate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCompaniesRequest generates requests for GetCompanies
func NewGetCompaniesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/companies/current")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompanyActivityRequest generates requests for GetCompanyActivity
func NewGetCompanyActivityRequest(server string, params *GetCompanyActivityParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/company_activity")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompanyLeaveTypesRequest generates requests for GetCompanyLeaveTypes
func NewGetCompanyLeaveTypesRequest(server string, params *GetCompanyLeaveTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/company_leave_types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ManagedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "managedBy", runtime.ParamLocationQuery, *params.ManagedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomFieldsRequest generates requests for GetCustomFields
func NewGetCustomFieldsRequest(server string, params *GetCustomFieldsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/custom_fields")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDepartmentsRequest generates requests for GetDepartments
func NewGetDepartmentsRequest(server string, params *GetDepartmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/departments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEmployeesRequest generates requests for GetEmployees
func NewGetEmployeesRequest(server string, params *GetEmployeesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/employees")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEmployeesIncludeTerminatedRequest generates requests for GetEmployeesIncludeTerminated
func NewGetEmployeesIncludeTerminatedRequest(server string, params *GetEmployeesIncludeTerminatedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/employees/include_terminated")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EIN != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "EIN", runtime.ParamLocationQuery, *params.EIN); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SendAllRoles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "send_all_roles", runtime.ParamLocationQuery, *params.SendAllRoles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEmployeesEmployeeIDRequest generates requests for GetEmployeesEmployeeID
func NewGetEmployeesEmployeeIDRequest(server string, employeeID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "employeeId", runtime.ParamLocationPath, employeeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/employees/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupsRequest generates requests for GetGroups
func NewGetGroupsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostGroupsRequest calls the generic PostGroups builder with application/json body
func NewPostGroupsRequest(server string, body PostGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostGroupsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostGroupsRequestWithBody generates requests for PostGroups with any type of body
func NewPostGroupsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupsGroupIDRequest generates requests for DeleteGroupsGroupID
func NewDeleteGroupsGroupIDRequest(server string, groupID int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupsGroupIDRequest calls the generic GetGroupsGroupID builder with application/json body
func NewGetGroupsGroupIDRequest(server string, groupID int, body GetGroupsGroupIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetGroupsGroupIDRequestWithBody(server, groupID, "application/json", bodyReader)
}

// NewGetGroupsGroupIDRequestWithBody generates requests for GetGroupsGroupID with any type of body
func NewGetGroupsGroupIDRequestWithBody(server string, groupID int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPatchGroupsGroupIDRequest calls the generic PatchGroupsGroupID builder with application/json body
func NewPatchGroupsGroupIDRequest(server string, groupID int, body PatchGroupsGroupIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchGroupsGroupIDRequestWithBody(server, groupID, "application/json", bodyReader)
}

// NewPatchGroupsGroupIDRequestWithBody generates requests for PatchGroupsGroupID with any type of body
func NewPatchGroupsGroupIDRequestWithBody(server string, groupID int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutGroupsGroupIDRequest calls the generic PutGroupsGroupID builder with application/json body
func NewPutGroupsGroupIDRequest(server string, groupID int, body PutGroupsGroupIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutGroupsGroupIDRequestWithBody(server, groupID, "application/json", bodyReader)
}

// NewPutGroupsGroupIDRequestWithBody generates requests for PutGroupsGroupID with any type of body
func NewPutGroupsGroupIDRequestWithBody(server string, groupID int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLeaveBalancesRequest generates requests for GetLeaveBalances
func NewGetLeaveBalancesRequest(server string, params *GetLeaveBalancesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/leave_balances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLeaveBalanceRequest generates requests for GetLeaveBalance
func NewGetLeaveBalanceRequest(server string, role string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "role", runtime.ParamLocationPath, role)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/leave_balances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLeaveRequestsRequest generates requests for GetLeaveRequests
func NewGetLeaveRequestsRequest(server string, params *GetLeaveRequestsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/leave_requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.ID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Role != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role", runtime.ParamLocationQuery, *params.Role); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequestedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requestedBy", runtime.ParamLocationQuery, *params.RequestedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeavePolicy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leavePolicy", runtime.ParamLocationQuery, *params.LeavePolicy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProcessedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processedBy", runtime.ParamLocationQuery, *params.ProcessedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostLeaveRequestsRequest calls the generic PostLeaveRequests builder with application/json body
func NewPostLeaveRequestsRequest(server string, body PostLeaveRequestsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostLeaveRequestsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostLeaveRequestsRequestWithBody generates requests for PostLeaveRequests with any type of body
func NewPostLeaveRequestsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/leave_requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPatchLeaveRequestsLeaveRequestIDRequest calls the generic PatchLeaveRequestsLeaveRequestID builder with application/json body
func NewPatchLeaveRequestsLeaveRequestIDRequest(server string, id string, body PatchLeaveRequestsLeaveRequestIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchLeaveRequestsLeaveRequestIDRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchLeaveRequestsLeaveRequestIDRequestWithBody generates requests for PatchLeaveRequestsLeaveRequestID with any type of body
func NewPatchLeaveRequestsLeaveRequestIDRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/leave_requests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelLeaveRequestsRequest generates requests for CancelLeaveRequests
func NewCancelLeaveRequestsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/leave_requests/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProcessLeaveRequestsRequest generates requests for ProcessLeaveRequests
func NewProcessLeaveRequestsRequest(server string, id string, params *ProcessLeaveRequestsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/leave_requests/%s/process", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, params.Action); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLevelsRequest generates requests for GetLevels
func NewGetLevelsRequest(server string, params *GetLevelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/levels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostMarkAppInstalledRequest generates requests for PostMarkAppInstalled
func NewPostMarkAppInstalledRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/mark_app_installed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMeRequest generates requests for GetMe
func NewGetMeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSamlIdpMetadataRequest generates requests for GetSamlIdpMetadata
func NewGetSamlIdpMetadataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/saml/idp_metadata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsRequest generates requests for GetTeams
func NewGetTeamsRequest(server string, params *GetTeamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkLocationsRequest generates requests for GetWorkLocations
func NewGetWorkLocationsRequest(server string, params *GetWorkLocationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/api/work_locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Rippling) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Rippling) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAppAppMatchingUsersWithResponse request
	GetAppAppMatchingUsersWithResponse(ctx context.Context, params *GetAppAppMatchingUsersParams, reqEditors ...RequestEditorFn) (*GetAppAppMatchingUsersRes, error)

	// PostAtsCandidatesPushCandidateWithBodyWithResponse request with any body
	PostAtsCandidatesPushCandidateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAtsCandidatesPushCandidateRes, error)

	PostAtsCandidatesPushCandidateWithResponse(ctx context.Context, body PostAtsCandidatesPushCandidateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAtsCandidatesPushCandidateRes, error)

	// GetCompaniesWithResponse request
	GetCompaniesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCompaniesRes, error)

	// GetCompanyActivityWithResponse request
	GetCompanyActivityWithResponse(ctx context.Context, params *GetCompanyActivityParams, reqEditors ...RequestEditorFn) (*GetCompanyActivityRes, error)

	// GetCompanyLeaveTypesWithResponse request
	GetCompanyLeaveTypesWithResponse(ctx context.Context, params *GetCompanyLeaveTypesParams, reqEditors ...RequestEditorFn) (*GetCompanyLeaveTypesRes, error)

	// GetCustomFieldsWithResponse request
	GetCustomFieldsWithResponse(ctx context.Context, params *GetCustomFieldsParams, reqEditors ...RequestEditorFn) (*GetCustomFieldsRes, error)

	// GetDepartmentsWithResponse request
	GetDepartmentsWithResponse(ctx context.Context, params *GetDepartmentsParams, reqEditors ...RequestEditorFn) (*GetDepartmentsRes, error)

	// GetEmployeesWithResponse request
	GetEmployeesWithResponse(ctx context.Context, params *GetEmployeesParams, reqEditors ...RequestEditorFn) (*GetEmployeesRes, error)

	// GetEmployeesIncludeTerminatedWithResponse request
	GetEmployeesIncludeTerminatedWithResponse(ctx context.Context, params *GetEmployeesIncludeTerminatedParams, reqEditors ...RequestEditorFn) (*GetEmployeesIncludeTerminatedRes, error)

	// GetEmployeesEmployeeIDWithResponse request
	GetEmployeesEmployeeIDWithResponse(ctx context.Context, employeeID string, reqEditors ...RequestEditorFn) (*GetEmployeesEmployeeIDRes, error)

	// GetGroupsWithResponse request
	GetGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGroupsRes, error)

	// PostGroupsWithBodyWithResponse request with any body
	PostGroupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGroupsRes, error)

	PostGroupsWithResponse(ctx context.Context, body PostGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGroupsRes, error)

	// DeleteGroupsGroupIDWithResponse request
	DeleteGroupsGroupIDWithResponse(ctx context.Context, groupID int, reqEditors ...RequestEditorFn) (*DeleteGroupsGroupIDRes, error)

	// GetGroupsGroupIDWithBodyWithResponse request with any body
	GetGroupsGroupIDWithBodyWithResponse(ctx context.Context, groupID int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetGroupsGroupIDRes, error)

	GetGroupsGroupIDWithResponse(ctx context.Context, groupID int, body GetGroupsGroupIDJSONRequestBody, reqEditors ...RequestEditorFn) (*GetGroupsGroupIDRes, error)

	// PatchGroupsGroupIDWithBodyWithResponse request with any body
	PatchGroupsGroupIDWithBodyWithResponse(ctx context.Context, groupID int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchGroupsGroupIDRes, error)

	PatchGroupsGroupIDWithResponse(ctx context.Context, groupID int, body PatchGroupsGroupIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchGroupsGroupIDRes, error)

	// PutGroupsGroupIDWithBodyWithResponse request with any body
	PutGroupsGroupIDWithBodyWithResponse(ctx context.Context, groupID int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutGroupsGroupIDRes, error)

	PutGroupsGroupIDWithResponse(ctx context.Context, groupID int, body PutGroupsGroupIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PutGroupsGroupIDRes, error)

	// GetLeaveBalancesWithResponse request
	GetLeaveBalancesWithResponse(ctx context.Context, params *GetLeaveBalancesParams, reqEditors ...RequestEditorFn) (*GetLeaveBalancesRes, error)

	// GetLeaveBalanceWithResponse request
	GetLeaveBalanceWithResponse(ctx context.Context, role string, reqEditors ...RequestEditorFn) (*GetLeaveBalanceRes, error)

	// GetLeaveRequestsWithResponse request
	GetLeaveRequestsWithResponse(ctx context.Context, params *GetLeaveRequestsParams, reqEditors ...RequestEditorFn) (*GetLeaveRequestsRes, error)

	// PostLeaveRequestsWithBodyWithResponse request with any body
	PostLeaveRequestsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLeaveRequestsRes, error)

	PostLeaveRequestsWithResponse(ctx context.Context, body PostLeaveRequestsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLeaveRequestsRes, error)

	// PatchLeaveRequestsLeaveRequestIDWithBodyWithResponse request with any body
	PatchLeaveRequestsLeaveRequestIDWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLeaveRequestsLeaveRequestIDRes, error)

	PatchLeaveRequestsLeaveRequestIDWithResponse(ctx context.Context, id string, body PatchLeaveRequestsLeaveRequestIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLeaveRequestsLeaveRequestIDRes, error)

	// CancelLeaveRequestsWithResponse request
	CancelLeaveRequestsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CancelLeaveRequestsRes, error)

	// ProcessLeaveRequestsWithResponse request
	ProcessLeaveRequestsWithResponse(ctx context.Context, id string, params *ProcessLeaveRequestsParams, reqEditors ...RequestEditorFn) (*ProcessLeaveRequestsRes, error)

	// GetLevelsWithResponse request
	GetLevelsWithResponse(ctx context.Context, params *GetLevelsParams, reqEditors ...RequestEditorFn) (*GetLevelsRes, error)

	// PostMarkAppInstalledWithResponse request
	PostMarkAppInstalledWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostMarkAppInstalledRes, error)

	// GetMeWithResponse request
	GetMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMeRes, error)

	// GetSamlIdpMetadataWithResponse request
	GetSamlIdpMetadataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSamlIdpMetadataRes, error)

	// GetTeamsWithResponse request
	GetTeamsWithResponse(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*GetTeamsRes, error)

	// GetWorkLocationsWithResponse request
	GetWorkLocationsWithResponse(ctx context.Context, params *GetWorkLocationsParams, reqEditors ...RequestEditorFn) (*GetWorkLocationsRes, error)
}

type GetAppAppMatchingUsersRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Results *[]struct {
			AppHandleID *struct {
				AppUserName *string `json:"app_user_name,omitempty"`
			} `json:"app_handle_id,omitempty"`
			RipplingEmployeeID *string `json:"rippling_employee_id,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAppAppMatchingUsersRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppAppMatchingUsersRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAtsCandidatesPushCandidateRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Candidate
}

// Status returns HTTPResponse.Status
func (r PostAtsCandidatesPushCandidateRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAtsCandidatesPushCandidateRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompaniesRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Company
}

// Status returns HTTPResponse.Status
func (r GetCompaniesRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompaniesRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompanyActivityRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data nullable.Nullable[struct {
			Events nullable.Nullable[[]Event] `json:"events,omitempty"`
			Next   *string                    `json:"next,omitempty"`
		}] `json:"data,omitempty"`
		Error nullable.Nullable[string] `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCompanyActivityRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompanyActivityRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompanyLeaveTypesRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CompanyLeaveType
}

// Status returns HTTPResponse.Status
func (r GetCompanyLeaveTypesRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompanyLeaveTypesRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomFieldsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CustomFields
}

// Status returns HTTPResponse.Status
func (r GetCustomFieldsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomFieldsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDepartmentsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Department
}

// Status returns HTTPResponse.Status
func (r GetDepartmentsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDepartmentsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmployeesRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Employee
}

// Status returns HTTPResponse.Status
func (r GetEmployeesRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmployeesRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmployeesIncludeTerminatedRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Employee
}

// Status returns HTTPResponse.Status
func (r GetEmployeesIncludeTerminatedRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmployeesIncludeTerminatedRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmployeesEmployeeIDRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Employee
}

// Status returns HTTPResponse.Status
func (r GetEmployeesEmployeeIDRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmployeesEmployeeIDRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Group
}

// Status returns HTTPResponse.Status
func (r GetGroupsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGroupsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Group
}

// Status returns HTTPResponse.Status
func (r PostGroupsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGroupsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupsGroupIDRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteGroupsGroupIDRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupsGroupIDRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsGroupIDRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
}

// Status returns HTTPResponse.Status
func (r GetGroupsGroupIDRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsGroupIDRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchGroupsGroupIDRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
}

// Status returns HTTPResponse.Status
func (r PatchGroupsGroupIDRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchGroupsGroupIDRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutGroupsGroupIDRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
}

// Status returns HTTPResponse.Status
func (r PutGroupsGroupIDRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutGroupsGroupIDRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLeaveBalancesRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Balances Leave balances object
		Balances *LeaveBalances `json:"balances,omitempty"`
		Role     *string        `json:"role,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLeaveBalancesRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLeaveBalancesRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLeaveBalanceRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Balances Leave balances object
		Balances *LeaveBalances `json:"balances,omitempty"`
		Role     *string        `json:"role,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLeaveBalanceRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLeaveBalanceRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLeaveRequestsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]LeaveRequest
}

// Status returns HTTPResponse.Status
func (r GetLeaveRequestsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLeaveRequestsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLeaveRequestsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LeaveRequest
}

// Status returns HTTPResponse.Status
func (r PostLeaveRequestsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLeaveRequestsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchLeaveRequestsLeaveRequestIDRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]LeaveRequest
}

// Status returns HTTPResponse.Status
func (r PatchLeaveRequestsLeaveRequestIDRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchLeaveRequestsLeaveRequestIDRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelLeaveRequestsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LeaveRequest
}

// Status returns HTTPResponse.Status
func (r CancelLeaveRequestsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelLeaveRequestsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessLeaveRequestsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LeaveRequest
}

// Status returns HTTPResponse.Status
func (r ProcessLeaveRequestsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessLeaveRequestsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLevelsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Level
}

// Status returns HTTPResponse.Status
func (r GetLevelsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLevelsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMarkAppInstalledRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`
	}
}

// Status returns HTTPResponse.Status
func (r PostMarkAppInstalledRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMarkAppInstalledRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMeRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthenticatedUserMe
}

// Status returns HTTPResponse.Status
func (r GetMeRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSamlIdpMetadataRes struct {
	Body         []byte
	HTTPResponse *http.Response
	XML200       *string
}

// Status returns HTTPResponse.Status
func (r GetSamlIdpMetadataRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSamlIdpMetadataRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Team
}

// Status returns HTTPResponse.Status
func (r GetTeamsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkLocationsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkLocation
}

// Status returns HTTPResponse.Status
func (r GetWorkLocationsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkLocationsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAppAppMatchingUsersWithResponse request returning *GetAppAppMatchingUsersRes
func (c *ClientWithResponses) GetAppAppMatchingUsersWithResponse(ctx context.Context, params *GetAppAppMatchingUsersParams, reqEditors ...RequestEditorFn) (*GetAppAppMatchingUsersRes, error) {
	rsp, err := c.GetAppAppMatchingUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppAppMatchingUsersRes(rsp)
}

// PostAtsCandidatesPushCandidateWithBodyWithResponse request with arbitrary body returning *PostAtsCandidatesPushCandidateRes
func (c *ClientWithResponses) PostAtsCandidatesPushCandidateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAtsCandidatesPushCandidateRes, error) {
	rsp, err := c.PostAtsCandidatesPushCandidateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAtsCandidatesPushCandidateRes(rsp)
}

func (c *ClientWithResponses) PostAtsCandidatesPushCandidateWithResponse(ctx context.Context, body PostAtsCandidatesPushCandidateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAtsCandidatesPushCandidateRes, error) {
	rsp, err := c.PostAtsCandidatesPushCandidate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAtsCandidatesPushCandidateRes(rsp)
}

// GetCompaniesWithResponse request returning *GetCompaniesRes
func (c *ClientWithResponses) GetCompaniesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCompaniesRes, error) {
	rsp, err := c.GetCompanies(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompaniesRes(rsp)
}

// GetCompanyActivityWithResponse request returning *GetCompanyActivityRes
func (c *ClientWithResponses) GetCompanyActivityWithResponse(ctx context.Context, params *GetCompanyActivityParams, reqEditors ...RequestEditorFn) (*GetCompanyActivityRes, error) {
	rsp, err := c.GetCompanyActivity(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompanyActivityRes(rsp)
}

// GetCompanyLeaveTypesWithResponse request returning *GetCompanyLeaveTypesRes
func (c *ClientWithResponses) GetCompanyLeaveTypesWithResponse(ctx context.Context, params *GetCompanyLeaveTypesParams, reqEditors ...RequestEditorFn) (*GetCompanyLeaveTypesRes, error) {
	rsp, err := c.GetCompanyLeaveTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompanyLeaveTypesRes(rsp)
}

// GetCustomFieldsWithResponse request returning *GetCustomFieldsRes
func (c *ClientWithResponses) GetCustomFieldsWithResponse(ctx context.Context, params *GetCustomFieldsParams, reqEditors ...RequestEditorFn) (*GetCustomFieldsRes, error) {
	rsp, err := c.GetCustomFields(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomFieldsRes(rsp)
}

// GetDepartmentsWithResponse request returning *GetDepartmentsRes
func (c *ClientWithResponses) GetDepartmentsWithResponse(ctx context.Context, params *GetDepartmentsParams, reqEditors ...RequestEditorFn) (*GetDepartmentsRes, error) {
	rsp, err := c.GetDepartments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDepartmentsRes(rsp)
}

// GetEmployeesWithResponse request returning *GetEmployeesRes
func (c *ClientWithResponses) GetEmployeesWithResponse(ctx context.Context, params *GetEmployeesParams, reqEditors ...RequestEditorFn) (*GetEmployeesRes, error) {
	rsp, err := c.GetEmployees(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEmployeesRes(rsp)
}

// GetEmployeesIncludeTerminatedWithResponse request returning *GetEmployeesIncludeTerminatedRes
func (c *ClientWithResponses) GetEmployeesIncludeTerminatedWithResponse(ctx context.Context, params *GetEmployeesIncludeTerminatedParams, reqEditors ...RequestEditorFn) (*GetEmployeesIncludeTerminatedRes, error) {
	rsp, err := c.GetEmployeesIncludeTerminated(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEmployeesIncludeTerminatedRes(rsp)
}

// GetEmployeesEmployeeIDWithResponse request returning *GetEmployeesEmployeeIDRes
func (c *ClientWithResponses) GetEmployeesEmployeeIDWithResponse(ctx context.Context, employeeID string, reqEditors ...RequestEditorFn) (*GetEmployeesEmployeeIDRes, error) {
	rsp, err := c.GetEmployeesEmployeeID(ctx, employeeID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEmployeesEmployeeIDRes(rsp)
}

// GetGroupsWithResponse request returning *GetGroupsRes
func (c *ClientWithResponses) GetGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGroupsRes, error) {
	rsp, err := c.GetGroups(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsRes(rsp)
}

// PostGroupsWithBodyWithResponse request with arbitrary body returning *PostGroupsRes
func (c *ClientWithResponses) PostGroupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGroupsRes, error) {
	rsp, err := c.PostGroupsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGroupsRes(rsp)
}

func (c *ClientWithResponses) PostGroupsWithResponse(ctx context.Context, body PostGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGroupsRes, error) {
	rsp, err := c.PostGroups(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGroupsRes(rsp)
}

// DeleteGroupsGroupIDWithResponse request returning *DeleteGroupsGroupIDRes
func (c *ClientWithResponses) DeleteGroupsGroupIDWithResponse(ctx context.Context, groupID int, reqEditors ...RequestEditorFn) (*DeleteGroupsGroupIDRes, error) {
	rsp, err := c.DeleteGroupsGroupID(ctx, groupID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupsGroupIDRes(rsp)
}

// GetGroupsGroupIDWithBodyWithResponse request with arbitrary body returning *GetGroupsGroupIDRes
func (c *ClientWithResponses) GetGroupsGroupIDWithBodyWithResponse(ctx context.Context, groupID int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetGroupsGroupIDRes, error) {
	rsp, err := c.GetGroupsGroupIDWithBody(ctx, groupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsGroupIDRes(rsp)
}

func (c *ClientWithResponses) GetGroupsGroupIDWithResponse(ctx context.Context, groupID int, body GetGroupsGroupIDJSONRequestBody, reqEditors ...RequestEditorFn) (*GetGroupsGroupIDRes, error) {
	rsp, err := c.GetGroupsGroupID(ctx, groupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsGroupIDRes(rsp)
}

// PatchGroupsGroupIDWithBodyWithResponse request with arbitrary body returning *PatchGroupsGroupIDRes
func (c *ClientWithResponses) PatchGroupsGroupIDWithBodyWithResponse(ctx context.Context, groupID int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchGroupsGroupIDRes, error) {
	rsp, err := c.PatchGroupsGroupIDWithBody(ctx, groupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchGroupsGroupIDRes(rsp)
}

func (c *ClientWithResponses) PatchGroupsGroupIDWithResponse(ctx context.Context, groupID int, body PatchGroupsGroupIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchGroupsGroupIDRes, error) {
	rsp, err := c.PatchGroupsGroupID(ctx, groupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchGroupsGroupIDRes(rsp)
}

// PutGroupsGroupIDWithBodyWithResponse request with arbitrary body returning *PutGroupsGroupIDRes
func (c *ClientWithResponses) PutGroupsGroupIDWithBodyWithResponse(ctx context.Context, groupID int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutGroupsGroupIDRes, error) {
	rsp, err := c.PutGroupsGroupIDWithBody(ctx, groupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutGroupsGroupIDRes(rsp)
}

func (c *ClientWithResponses) PutGroupsGroupIDWithResponse(ctx context.Context, groupID int, body PutGroupsGroupIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PutGroupsGroupIDRes, error) {
	rsp, err := c.PutGroupsGroupID(ctx, groupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutGroupsGroupIDRes(rsp)
}

// GetLeaveBalancesWithResponse request returning *GetLeaveBalancesRes
func (c *ClientWithResponses) GetLeaveBalancesWithResponse(ctx context.Context, params *GetLeaveBalancesParams, reqEditors ...RequestEditorFn) (*GetLeaveBalancesRes, error) {
	rsp, err := c.GetLeaveBalances(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLeaveBalancesRes(rsp)
}

// GetLeaveBalanceWithResponse request returning *GetLeaveBalanceRes
func (c *ClientWithResponses) GetLeaveBalanceWithResponse(ctx context.Context, role string, reqEditors ...RequestEditorFn) (*GetLeaveBalanceRes, error) {
	rsp, err := c.GetLeaveBalance(ctx, role, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLeaveBalanceRes(rsp)
}

// GetLeaveRequestsWithResponse request returning *GetLeaveRequestsRes
func (c *ClientWithResponses) GetLeaveRequestsWithResponse(ctx context.Context, params *GetLeaveRequestsParams, reqEditors ...RequestEditorFn) (*GetLeaveRequestsRes, error) {
	rsp, err := c.GetLeaveRequests(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLeaveRequestsRes(rsp)
}

// PostLeaveRequestsWithBodyWithResponse request with arbitrary body returning *PostLeaveRequestsRes
func (c *ClientWithResponses) PostLeaveRequestsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLeaveRequestsRes, error) {
	rsp, err := c.PostLeaveRequestsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLeaveRequestsRes(rsp)
}

func (c *ClientWithResponses) PostLeaveRequestsWithResponse(ctx context.Context, body PostLeaveRequestsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLeaveRequestsRes, error) {
	rsp, err := c.PostLeaveRequests(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLeaveRequestsRes(rsp)
}

// PatchLeaveRequestsLeaveRequestIDWithBodyWithResponse request with arbitrary body returning *PatchLeaveRequestsLeaveRequestIDRes
func (c *ClientWithResponses) PatchLeaveRequestsLeaveRequestIDWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLeaveRequestsLeaveRequestIDRes, error) {
	rsp, err := c.PatchLeaveRequestsLeaveRequestIDWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLeaveRequestsLeaveRequestIDRes(rsp)
}

func (c *ClientWithResponses) PatchLeaveRequestsLeaveRequestIDWithResponse(ctx context.Context, id string, body PatchLeaveRequestsLeaveRequestIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLeaveRequestsLeaveRequestIDRes, error) {
	rsp, err := c.PatchLeaveRequestsLeaveRequestID(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLeaveRequestsLeaveRequestIDRes(rsp)
}

// CancelLeaveRequestsWithResponse request returning *CancelLeaveRequestsRes
func (c *ClientWithResponses) CancelLeaveRequestsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CancelLeaveRequestsRes, error) {
	rsp, err := c.CancelLeaveRequests(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelLeaveRequestsRes(rsp)
}

// ProcessLeaveRequestsWithResponse request returning *ProcessLeaveRequestsRes
func (c *ClientWithResponses) ProcessLeaveRequestsWithResponse(ctx context.Context, id string, params *ProcessLeaveRequestsParams, reqEditors ...RequestEditorFn) (*ProcessLeaveRequestsRes, error) {
	rsp, err := c.ProcessLeaveRequests(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessLeaveRequestsRes(rsp)
}

// GetLevelsWithResponse request returning *GetLevelsRes
func (c *ClientWithResponses) GetLevelsWithResponse(ctx context.Context, params *GetLevelsParams, reqEditors ...RequestEditorFn) (*GetLevelsRes, error) {
	rsp, err := c.GetLevels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLevelsRes(rsp)
}

// PostMarkAppInstalledWithResponse request returning *PostMarkAppInstalledRes
func (c *ClientWithResponses) PostMarkAppInstalledWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostMarkAppInstalledRes, error) {
	rsp, err := c.PostMarkAppInstalled(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMarkAppInstalledRes(rsp)
}

// GetMeWithResponse request returning *GetMeRes
func (c *ClientWithResponses) GetMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMeRes, error) {
	rsp, err := c.GetMe(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMeRes(rsp)
}

// GetSamlIdpMetadataWithResponse request returning *GetSamlIdpMetadataRes
func (c *ClientWithResponses) GetSamlIdpMetadataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSamlIdpMetadataRes, error) {
	rsp, err := c.GetSamlIdpMetadata(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSamlIdpMetadataRes(rsp)
}

// GetTeamsWithResponse request returning *GetTeamsRes
func (c *ClientWithResponses) GetTeamsWithResponse(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*GetTeamsRes, error) {
	rsp, err := c.GetTeams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsRes(rsp)
}

// GetWorkLocationsWithResponse request returning *GetWorkLocationsRes
func (c *ClientWithResponses) GetWorkLocationsWithResponse(ctx context.Context, params *GetWorkLocationsParams, reqEditors ...RequestEditorFn) (*GetWorkLocationsRes, error) {
	rsp, err := c.GetWorkLocations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkLocationsRes(rsp)
}

// ParseGetAppAppMatchingUsersRes parses an HTTP response from a GetAppAppMatchingUsersWithResponse call
func ParseGetAppAppMatchingUsersRes(rsp *http.Response) (*GetAppAppMatchingUsersRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppAppMatchingUsersRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Results *[]struct {
				AppHandleID *struct {
					AppUserName *string `json:"app_user_name,omitempty"`
				} `json:"app_handle_id,omitempty"`
				RipplingEmployeeID *string `json:"rippling_employee_id,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostAtsCandidatesPushCandidateRes parses an HTTP response from a PostAtsCandidatesPushCandidateWithResponse call
func ParsePostAtsCandidatesPushCandidateRes(rsp *http.Response) (*PostAtsCandidatesPushCandidateRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAtsCandidatesPushCandidateRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Candidate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCompaniesRes parses an HTTP response from a GetCompaniesWithResponse call
func ParseGetCompaniesRes(rsp *http.Response) (*GetCompaniesRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompaniesRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Company
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCompanyActivityRes parses an HTTP response from a GetCompanyActivityWithResponse call
func ParseGetCompanyActivityRes(rsp *http.Response) (*GetCompanyActivityRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompanyActivityRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data nullable.Nullable[struct {
				Events nullable.Nullable[[]Event] `json:"events,omitempty"`
				Next   *string                    `json:"next,omitempty"`
			}] `json:"data,omitempty"`
			Error nullable.Nullable[string] `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCompanyLeaveTypesRes parses an HTTP response from a GetCompanyLeaveTypesWithResponse call
func ParseGetCompanyLeaveTypesRes(rsp *http.Response) (*GetCompanyLeaveTypesRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompanyLeaveTypesRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CompanyLeaveType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCustomFieldsRes parses an HTTP response from a GetCustomFieldsWithResponse call
func ParseGetCustomFieldsRes(rsp *http.Response) (*GetCustomFieldsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomFieldsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CustomFields
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDepartmentsRes parses an HTTP response from a GetDepartmentsWithResponse call
func ParseGetDepartmentsRes(rsp *http.Response) (*GetDepartmentsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDepartmentsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Department
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEmployeesRes parses an HTTP response from a GetEmployeesWithResponse call
func ParseGetEmployeesRes(rsp *http.Response) (*GetEmployeesRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEmployeesRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Employee
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEmployeesIncludeTerminatedRes parses an HTTP response from a GetEmployeesIncludeTerminatedWithResponse call
func ParseGetEmployeesIncludeTerminatedRes(rsp *http.Response) (*GetEmployeesIncludeTerminatedRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEmployeesIncludeTerminatedRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Employee
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEmployeesEmployeeIDRes parses an HTTP response from a GetEmployeesEmployeeIDWithResponse call
func ParseGetEmployeesEmployeeIDRes(rsp *http.Response) (*GetEmployeesEmployeeIDRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEmployeesEmployeeIDRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Employee
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGroupsRes parses an HTTP response from a GetGroupsWithResponse call
func ParseGetGroupsRes(rsp *http.Response) (*GetGroupsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostGroupsRes parses an HTTP response from a PostGroupsWithResponse call
func ParsePostGroupsRes(rsp *http.Response) (*PostGroupsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGroupsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteGroupsGroupIDRes parses an HTTP response from a DeleteGroupsGroupIDWithResponse call
func ParseDeleteGroupsGroupIDRes(rsp *http.Response) (*DeleteGroupsGroupIDRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupsGroupIDRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGroupsGroupIDRes parses an HTTP response from a GetGroupsGroupIDWithResponse call
func ParseGetGroupsGroupIDRes(rsp *http.Response) (*GetGroupsGroupIDRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsGroupIDRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchGroupsGroupIDRes parses an HTTP response from a PatchGroupsGroupIDWithResponse call
func ParsePatchGroupsGroupIDRes(rsp *http.Response) (*PatchGroupsGroupIDRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchGroupsGroupIDRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutGroupsGroupIDRes parses an HTTP response from a PutGroupsGroupIDWithResponse call
func ParsePutGroupsGroupIDRes(rsp *http.Response) (*PutGroupsGroupIDRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutGroupsGroupIDRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLeaveBalancesRes parses an HTTP response from a GetLeaveBalancesWithResponse call
func ParseGetLeaveBalancesRes(rsp *http.Response) (*GetLeaveBalancesRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLeaveBalancesRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Balances Leave balances object
			Balances *LeaveBalances `json:"balances,omitempty"`
			Role     *string        `json:"role,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLeaveBalanceRes parses an HTTP response from a GetLeaveBalanceWithResponse call
func ParseGetLeaveBalanceRes(rsp *http.Response) (*GetLeaveBalanceRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLeaveBalanceRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Balances Leave balances object
			Balances *LeaveBalances `json:"balances,omitempty"`
			Role     *string        `json:"role,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLeaveRequestsRes parses an HTTP response from a GetLeaveRequestsWithResponse call
func ParseGetLeaveRequestsRes(rsp *http.Response) (*GetLeaveRequestsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLeaveRequestsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LeaveRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostLeaveRequestsRes parses an HTTP response from a PostLeaveRequestsWithResponse call
func ParsePostLeaveRequestsRes(rsp *http.Response) (*PostLeaveRequestsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLeaveRequestsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LeaveRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParsePatchLeaveRequestsLeaveRequestIDRes parses an HTTP response from a PatchLeaveRequestsLeaveRequestIDWithResponse call
func ParsePatchLeaveRequestsLeaveRequestIDRes(rsp *http.Response) (*PatchLeaveRequestsLeaveRequestIDRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchLeaveRequestsLeaveRequestIDRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LeaveRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCancelLeaveRequestsRes parses an HTTP response from a CancelLeaveRequestsWithResponse call
func ParseCancelLeaveRequestsRes(rsp *http.Response) (*CancelLeaveRequestsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelLeaveRequestsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LeaveRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProcessLeaveRequestsRes parses an HTTP response from a ProcessLeaveRequestsWithResponse call
func ParseProcessLeaveRequestsRes(rsp *http.Response) (*ProcessLeaveRequestsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessLeaveRequestsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LeaveRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLevelsRes parses an HTTP response from a GetLevelsWithResponse call
func ParseGetLevelsRes(rsp *http.Response) (*GetLevelsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLevelsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Level
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostMarkAppInstalledRes parses an HTTP response from a PostMarkAppInstalledWithResponse call
func ParsePostMarkAppInstalledRes(rsp *http.Response) (*PostMarkAppInstalledRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostMarkAppInstalledRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMeRes parses an HTTP response from a GetMeWithResponse call
func ParseGetMeRes(rsp *http.Response) (*GetMeRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMeRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthenticatedUserMe
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSamlIdpMetadataRes parses an HTTP response from a GetSamlIdpMetadataWithResponse call
func ParseGetSamlIdpMetadataRes(rsp *http.Response) (*GetSamlIdpMetadataRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSamlIdpMetadataRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest string
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetTeamsRes parses an HTTP response from a GetTeamsWithResponse call
func ParseGetTeamsRes(rsp *http.Response) (*GetTeamsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWorkLocationsRes parses an HTTP response from a GetWorkLocationsWithResponse call
func ParseGetWorkLocationsRes(rsp *http.Response) (*GetWorkLocationsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkLocationsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkLocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
